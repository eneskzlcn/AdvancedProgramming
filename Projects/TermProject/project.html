<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Fatal Climb</title>
    <!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: rgb(176, 233, 235); display: block; margin: 50 auto;}
      div {background: rgb(176, 233, 235);display: block;}
    </style>
</head>
<body>
<script>
    "use strict"
    //initializing canvas
	  var canvas = 0;
    var ctx = 0;
    //--------------------------------
    //defining game objects and global variables
    var char = {pos:{x:0,y:0},width:0,height:0,gravity_magnitude:0,speed:{x:0,y:0},
    jumpMagnitude:0,img: new Image(),onGround:false}
    var apartment_left = {pos:{x:0,y:0},width:0,height:0,speed:{x:0,y:0},img:new Image()}
    var apartment_right = {pos:{x:0,y:0},width:0,height:0,speed:{x:0,y:0},img:new Image()};
    var platforms = []
    const platforms_spawn_point_y =-440;
    const char_gravity_magnitude= 2;
    const platform_gravity_magnitude = 1;
    let is_game_over = false;
    var gameIntervalID = 0
    //-------------------------------
    //Adding listener funct. if exists
    document.addEventListener("keydown", keyDownHandler,false);  

    //initializing all the game before start...
    function init_game()  
    {
      is_game_over = false;
      platforms = []
      canvas = document.createElement("canvas");
      canvas.width = 400
      canvas.height = 400
      document.body.appendChild(canvas);
      ctx = canvas.getContext("2d");
      initializeApartments()//sağa doğru x artıyor.yukarı doğru y azalıyor.
      initializeCharacter();
      initializePlatforms();
    }
    //initializing apartments
    function initializeApartments()
    {// apartments are constants. their position will never change... width,height == img.width,img.height
      apartment_left.width=50,apartment_left.height = canvas.height,apartment_left.img.src="wall.png";
      apartment_right.width=50,apartment_right.height = canvas.height,apartment_right.img.src="wall.png",
      apartment_right.pos.x = canvas.width-50;
    }
    //initalizing character
    function initializeCharacter()
    {
      char.pos.x = canvas.width/2,char.pos.y=canvas.height/2,char.width = 64,char.height=64,
      char.gravity_magnitude=char_gravity_magnitude, char.speed.x = 70,char.jumpMagnitude=70,char.img.src="character.png",
      char.onGround = false
    }
    function makeStartPanel()
    {
      //game panel
      let panel = document.createElement("div")
      panel.style.width = "400px"
      panel.style.height = "400px"
      document.body.appendChild(panel);
      //game name
      let gameName = document.createElement("h1")
      gameName.style.fontSize = "40px"
      gameName.innerText = "FATAL CLIMB"
      panel.appendChild(gameName);
      //start button
      let startButton = document.createElement("button")
      let buttonIcon = document.createElement("i")
      buttonIcon.className = "fa fa-play"
      startButton.appendChild(buttonIcon)
      startButton.style.fontSize = "40px"
      startButton.style.width = "100px"
      startButton.style.color = "red"
      startButton.style.marginTop = "50px"
      panel.appendChild(startButton)
      startButton.addEventListener("click",()=>
      {
        document.body.removeChild(panel)
        init_game()
        gameIntervalID = setInterval(game,20)
      })

      //init_game();
      //gameIntervalID = setInterval(game,10); //this is the update method of javascript //running for every 10 ms forever...
    }
    function initializePlatforms()
    {
      
      var left_side_platform_x = apartment_left.width;
      let platforms_y = 360;
      let padding_btw_platforms= 80;
      let i = 0;
      while(platforms_y >= platforms_spawn_point_y)
      {
        let platform_width = 120;//Do this randomly if you can
        //right_side-platform_x changes by the platform_width. So it defined inner this loop not out of it.
        let right_side_platform_x = canvas.width-apartment_right.width-platform_width
        if(i%2 == 0)
        {
          platforms[i]= {pos:{x:left_side_platform_x,y:platforms_y},width:platform_width,height:20,gravity_magnitude:platform_gravity_magnitude}
        }
        else
        {
          platforms[i]= {pos:{x:right_side_platform_x,y:platforms_y},width:platform_width,height:20,gravity_magnitude:platform_gravity_magnitude}

        }
        platforms_y -= padding_btw_platforms;
        i++;
      }
    }
    
    function drawCharacter() 
    {
        ctx.beginPath();
        ctx.drawImage(char.img,char.pos.x,char.pos.y);
        ctx.closePath();
    }
    function drawApartments()
    {
        ctx.beginPath();
        ctx.drawImage(apartment_left.img,apartment_left.pos.x,apartment_left.pos.y);
        ctx.drawImage(apartment_right.img,apartment_right.pos.x,apartment_right.pos.y);
        ctx.closePath();

    }
    function drawPlatforms()
    {
      for(let platform of platforms)
      {
        ctx.beginPath();
        ctx.rect(platform.pos.x,platform.pos.y,platform.width,platform.height)
        ctx.fillStyle= "#0095DD"
        ctx.fill();
        ctx.closePath();

      }
    }
    // There will be only about x platform for optimization. When one of them disappear from bottom,
    //y value of it will be changed to spawn_y point instead of remove it and add new platform.
    // the name of this operation will be platformRecycling...
    function handlePlatformsRecycling()
    {
      for(let platform of platforms)
      {
        if (platform.pos.y >= canvas.width)
        {
          platform.pos.y = platforms_spawn_point_y
          platform.gravity_magnitude= platform_gravity_magnitude;
        }
      }
    }
    function game()
    {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCharacter();
        drawApartments();
        drawPlatforms();
        handlePlatformsRecycling();
        handleGravity();
        onCollision();
        gameOverHandler();
    }
    function keyDownHandler(e)
    {
        if(e.key == "ArrowUp")
        {
          handleJump();
        }
        if(e.key == "ArrowRight")
        {
          setIntervalX(()=>char.pos.x += char.speed.x/10,20,10)
        // char.pos.x+= char.speed.x/5;
 
        }
        else if(e.key == "ArrowLeft")
        {
          //char.pos.x-= char.speed.x/5;
         setIntervalX(()=>char.pos.x -= char.speed.x/10,20,10)
        }
      }
    //this func. is taken from stackoverflow.com as the answer of the question(answered by Daniel Vassallo)
    // 'Javascript - telling setInterval to only fire x amount of times?''
    // This funct. used in movement to the left,right and also jump. Before not using this func. and
    // say jump to character about 10 units, it was seen like it is teleporting to that point. It wasn't good.
    // Now this function provides to do that if jump then start the move 1 by 1 to the 10 units with a paramater delay
    //and this is seen like the character is really moving or jumping.
    function setIntervalX(callback, delay, repetitions)
    {
      var x = 0;
      var intervalID = window.setInterval(function () {

        callback();

        if (++x === repetitions) {
            window.clearInterval(intervalID);
        }
      }, delay);
    }
    
    function gameOverHandler()
    {
      if(is_game_over)
      {
        clearInterval(gameIntervalID);
        let gameOverText = document.createElement("h1")
        gameOverText.innerText = "GAME OVER!"
        canvas.appendChild(gameOverText)
        //initialize game over screen;
        //
      }
    }
    
    function onCollision()//control character is colliding with any apartment or any platform...
    {
      if (char.pos.y > canvas.width)
      {
        is_game_over = true;//character is already falled down
      }
      if(char.pos.x <= apartment_left.pos.x + apartment_left.width)//character is colliding with left apartment
      {
        char.pos.x = apartment_left.pos.x + apartment_left.width
      }
      else if(char.pos.x+char.width >= apartment_right.pos.x)//character is colliding with left apartment
      {
        char.pos.x = apartment_right.pos.x - char.width//character is colliding with right apartments
      }
      for(let plat of platforms)
      {
         handlePlatformCollision(plat);
      }
    }
    function handleJump()
    {
      let place = {pos:{x:char.pos.x,y:char.pos.y+2},width:char.width,height:char.height}
      if(char.onGround)
      {
        setIntervalX(()=>char.pos.y -= char.jumpMagnitude/5,20,10)
      }
      char.onGround = false;
    }
    function handleGravity()
    {
      for(let plt of platforms) //platforms are effected of gravity
      {
        plt.pos.y += plt.gravity_magnitude;
      }
      char.pos.y += char.gravity_magnitude //character is effected of gravity
    }

    //this functions seems to control every thing on collision because of its name. But it only controls if
    //the character is on collision with a platform. Only character is needed to be controlled if is colliding with a platform.
    function handlePlatformCollision(platform)
    {
      //this control statements enough the control is it colliding.
       if(char.pos.x+char.width > platform.pos.x && char.pos.x +char.width< platform.pos.x+platform.width &&
         char.pos.y+char.height > platform.pos.y && char.pos.y+char.height< platform.pos.y + platform.height)
         { 
           //control if character is colliding from bottom side (if its head is more closer to platform_y)
           //or top side ( foots of the character on ground).If character hits its head from bot side 
           //to the platform the game will over. If only falling down to the platform,it is the things need
          // to be done.
          if(char.pos.y<platform.pos.y)//falling from top
          {
            char.onGround = true;
            char.pos.y = platform.pos.y-char.height;
            platform.gravity_magnitude = char.gravity_magnitude; // keep moving with platform until jump
            return;
          }
          else if(char.pos.y > platform.pos.y)
          {
            is_game_over = true; // hitting head from bottom
            return;
          }
         }
    }
    function isPlaceFree(place)
    {
      let isFree = true;
      for(let platform of platforms)
      {
        if(place.pos.x > platform.pos.x && place.pos.x <platform.pos.x+platform.width &&
        place.pos.y > platform.pos.y && place.pos.y < platform.pos.y + platform.height)
        { 
          isFree = false;
          break;
        }
      }
      return isFree;
    }
    makeStartPanel();
</script>

</body>
</html>